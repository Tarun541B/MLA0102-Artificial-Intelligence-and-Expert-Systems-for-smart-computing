from collections import deque

# Each state is represented as (x, y)
# x: amount of water in 4-gallon jug
# y: amount of water in 3-gallon jug

def get_next_states(x, y):
    next_states = []

    # Jug capacities
    max4, max3 = 4, 3

    # 1. Fill operations
    next_states.append((max4, y))  # Fill 4-gallon jug
    next_states.append((x, max3))  # Fill 3-gallon jug

    # 2. Empty operations
    next_states.append((0, y))  # Empty 4-gallon jug
    next_states.append((x, 0))  # Empty 3-gallon jug

    # 3. Pour from 4 -> 3
    pour = min(x, max3 - y)
    next_states.append((x - pour, y + pour))

    # 4. Pour from 3 -> 4
    pour = min(y, max4 - x)
    next_states.append((x + pour, y - pour))

    return next_states


def bfs():
    start = (0, 0)
    goal = 2  # We want 2 gallons in the 4-gallon jug
    queue = deque([start])
    visited = set([start])
    parent = {start: None}

    while queue:
        state = queue.popleft()
        x, y = state

        if x == goal:
            # Goal found, reconstruct path
            path = []
            while state:
                path.append(state)
                state = parent[state]
            return path[::-1]

        for next_state in get_next_states(x, y):
            if next_state not in visited:
                visited.add(next_state)
                queue.append(next_state)
                parent[next_state] = (x, y)

    return None


# Run BFS
solution = bfs()

if solution:
    print("Steps to solve Water Jug Problem:")
    for step in solution:
        print(step)
else:
    print("No solution found")
